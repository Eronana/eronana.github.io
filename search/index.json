[["Wrong alpha premultiplication on iOS Safari","2022年09月09日","/2022/09/16/wrong-alpha-premultiplication-on-ios-safari/"," Problem The PNG supports 4 channels called , and we usually use the alpha channel for opacity. But there is a different usecase to the alpha channel, the emissive intensity. The finally color will be added to the . In the fragment shader it would look like: Let\u0026rsquo;s generate a PNG image to render. Save the code to , and run to install dependencies. Run to get the . The below tables show the results in different browsers. Original Your browser macOS Chrome macOS Safari iOS Safari The result of seems so different, all pixels with 0 alpha become black. It seems iOS Safari did the wrong premultiplication on images. Solutions Is there any way to solve the problem? Yes, I came up with 3 solutions: Do not do this. If you want 4 channels and alpha channel is not for opacity, then just use two textures. Do not use image, you can put image data into a binary file and read it as a and load it into a texture. Use a PNG decoder to directly decode the image, then you can get a clear image data. "],["Using Node.js to generate indexed PNG","2022年09月09日","/2022/09/15/using-node.js-to-generate-indexed-png/"," A glance of indexed PNG Most PNG images have three or four channels, that indicate RGB or RGBA. But PNG files also support indexed images, so you can put a palette into it and use one channel to indicate the palette index to represent the image. In this article, we are going to discuss how to generate indexed PNG images in Node.js. According to the wiki Portable Network Graphics , we know several parts of png: Every png file starts with an 8-byte PNG signature: . Followings are chunks. the structure of chunks is: : 4 bytes : 4 bytes : length bytes : 4 bytes The 4 chunks are required for indexed PNG is , , , and . Preparation First of all, we should decide how the image should be created. I think a colorful 16*16-sized image would be good. Then we need an array of to store the PNG data. Then we can use to append chunk buffers to the data. Header Following the PNG format, just write the header. Chunks To write chunks properly, we need to implement a function called : There are 4 chunks to be written, let\u0026rsquo;s solve them one by one. IHDR There are so many fields in IHDR, but only the width and height are what we really care about. PLTE The palette, let\u0026rsquo;s just make a colorful 256-length palette. IDAT This chunk is the actual image data chunk, it includes indices of the color. We can just fill it from to to show all colors in the palette sequential. The data of IDAT chunk should be compressed by Deflate, the should be used. The pre-compressed data should contain height rows, and each line starts with a filter type. Indexed PNG does not need any filter, which means each row should start with 0(None). Since there is an extra byte indicating filter type in rows, the size of the data is (width + 1) * height = (16 + 1) * 16; IEND No data with chunk IEND, just create an empty Buffer as data. Save to file Now we can concatenate the chunks to get the data buffer of the png image and write it into a file. The indexed-png I\u0026rsquo;ve created a package called indexed-png to do this, you can use it to generate a indexed png easily: "]]